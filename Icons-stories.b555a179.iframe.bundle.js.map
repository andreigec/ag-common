{"version":3,"file":"Icons-stories.b555a179.iframe.bundle.js","mappings":";;;;;;;;;;;;AAmBA;;;;AAIA;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;ACpBA;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACeA;;;;;;;;;;;;;;;;;ACnCA;;;;;;AAMA;;;;;;AAMA;;;;;;;;;;;;;;;;;;ACVA;;;AAeA;;;;;;;ACZA;;;AAKA;;;ACTA;;;;;;;AAQA;;;;;;AAQA;;;;;;;AASA;;;;;;AAOA;;;;;;AAQA;;;;;AAOA;;ACjDA;;AAGA;;;AAKA;;;;;AAMA;;;;;;;;AAUA;;;;;;;AChBA;;;;;;AAQA;;;;;;;;;;;;;;;;ACAA;AACA;AAGA;AACA;AAGA;;;;;;;AASA;;AAEA;;AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAKA;AACA;AAGA;AACA;AAcA;;;;;ACxDA;;;;AAMA;;;;;;AAQA;;;AAKA;;;;;;AAQA;;;;;;;;;ACtBA;;;;AAMA;;;;;;;;;AA8BA;;;;;;;;;;;;;;;;AClCA;;;;;;;;;;;;;;;;ACFA;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;;;;;;;;;;;;;;;;;;;;ACgJA;;;;;AC7LA;;AAIA;;;;;;;;AAUA;;;;;AAOA;;;;AAkBA;;;ACpCA;;;;;;;ACJA;;;;;AAOA;;;;;;;;;;;AA2BA;;;;;AC/BA;;;;AAMA;;;;;;AAQA;;;AAKA;;;;;;AAOA;;;;;;;;AC5BA;;;;;;;;;;;AA2BA;;;;;;AC3BA;;;AAIA;;;;;;;;AASA;;;;;;;;;AASA;;;AAUA;;;;;;;;;;;;ACvBA;;;;;;;;AAQA;;;;;;;;;;AAUA;;;;;;;;AAQA;;;;AAIA;AACA;;AAEA;;;;AAMA;;;;AAMA;AACA;;;;;;;;;AASA;;AAEA;;;AAKA;;;;;;;;;;;AAaA;;;;;;AAMA;;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;AAeA;;;;;;;;;ACzIA;;AAZA;AAAA;AAAA;AAmBA;;AAnBA;AAmCA;;;;;;;;;;ACtBA;;;;;;;;;;;;;;AAeA;;;;AAKA;;;AA0BA;;;;;;ACnDA;;;;;;;;;AAWA;;;;AAMA;;AAIA;;;;AAgBA;;;;AC1CA;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;AA8BA;;;;;;;;;;ACjBA;;;;;;;;;;;ACAA;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;AAmBA;;;;AAMA;;;AAKA;;;;;ACtEA;;AAIA;;;;ACGA;;;;AAKA;;;;;;;;;;;;;;;AAiBA;;;AAGA;AACA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;;;;AAcA","sources":["webpack://ag-common/./src/ui/components/Image/index.tsx","webpack://ag-common/./src/ui/components/InfiniteScroll/index.tsx","webpack://ag-common/./src/ui/components/PulseRing/index.tsx","webpack://ag-common/./src/ui/components/RowOrColumn/index.tsx","webpack://ag-common/./src/ui/components/Accordion/index.tsx","webpack://ag-common/./src/ui/components/BarChart/Item.tsx","webpack://ag-common/./src/ui/components/BarChart/Legend.tsx","webpack://ag-common/./src/ui/components/BarChart/TooltipContent.tsx","webpack://ag-common/./src/ui/components/BarChart/Base.tsx","webpack://ag-common/./src/ui/components/BorderGradient/index.tsx","webpack://ag-common/./src/ui/components/Button/index.tsx","webpack://ag-common/./src/ui/components/Confirm/Modal.tsx","webpack://ag-common/./src/ui/components/DarkMode/Base.tsx","webpack://ag-common/./src/ui/components/FlexColumn/index.tsx","webpack://ag-common/./src/ui/components/Loader/index.tsx","webpack://ag-common/./src/ui/components/Markdown/index.tsx","webpack://ag-common/./src/ui/components/MinSidebar/index.tsx","webpack://ag-common/./src/ui/components/PieChart/index.tsx","webpack://ag-common/./src/ui/components/ProgressBar/index.tsx","webpack://ag-common/./src/ui/components/Prompt/Modal.tsx","webpack://ag-common/./src/ui/components/RadioGroup/index.tsx","webpack://ag-common/./src/ui/components/Search/AutoHideSearchBox.tsx","webpack://ag-common/./src/ui/components/Sidebar/index.tsx","webpack://ag-common/./src/ui/components/SparkLine/index.tsx","webpack://ag-common/./src/ui/components/TabBar/index.tsx","webpack://ag-common/./src/ui/components/Table/index.tsx","webpack://ag-common/./src/ui/components/TextWithButton/index.tsx","webpack://ag-common/./src/ui/components/TimelineChart/index.tsx","webpack://ag-common/./src/ui/components/Toast/base.tsx","webpack://ag-common/./src/ui/components/TreeChart/TooltipContent.tsx","webpack://ag-common/./src/ui/components/TreeChart/base.tsx","webpack://ag-common/./src/ui/components/UserImage/index.tsx"],"sourcesContent":["'use client';\nimport styled from '@emotion/styled';\nimport type { ImgHTMLAttributes } from 'react';\nimport React, { useState } from 'react';\n\nimport { bigScreen, smallScreen } from '../../styles/media';\n\nconst Base = styled.img`\n  object-fit: contain;\n  width: 100%;\n  height: 100%;\n\n  min-width: 5rem;\n  min-height: 5rem;\n\n  max-width: 100%;\n  max-height: 100%;\n\n  &[data-smalltop='true'] {\n    @media ${smallScreen} {\n      order: -1;\n    }\n  }\n  @media ${smallScreen} {\n    max-width: 50vw;\n    max-height: 50vh;\n\n    &[data-bigonly='true'] {\n      display: none;\n    }\n    &[data-small='true'] {\n      max-width: 25vw;\n      max-height: 25vh;\n    }\n  }\n\n  @media ${bigScreen} {\n    max-width: 50vw;\n    max-height: 50vh;\n    &[data-smallonly='true'] {\n      display: none;\n    }\n    &[data-small='true'] {\n      max-width: 30vw;\n      max-height: 30vh;\n    }\n  }\n`;\n\nexport interface IImage {\n  /** if true, will set order to -1 for mobile. default false */\n  smalltop?: boolean;\n  /** if true, will hide on mobile. default false */\n  bigonly?: boolean;\n  /** if true, will hide on desktop. default false */\n  smallonly?: boolean;\n  /** if true is counted as a small image, and will be sized accordingly. default false */\n  small?: boolean;\n}\nexport const Image = (p: ImgHTMLAttributes<HTMLImageElement> & IImage) => {\n  const { smalltop, bigonly, smallonly, small, ...p1 } = p;\n  const [display, setDisplay] = useState(true);\n  if (!display) {\n    return null;\n  }\n\n  return (\n    <Base\n      {...p1}\n      data-smalltop={smalltop}\n      data-bigonly={bigonly}\n      data-smallonly={smallonly}\n      data-small={small}\n      onError={() => setDisplay(false)}\n    />\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { createRef, useEffect, useState } from 'react';\n\nimport { debounce } from '../../helpers/debounce';\nimport { filterDataProps } from '../../helpers/dom';\n\nconst Base = styled.div`\n  overflow-y: auto;\n  height: 100%;\n  width: 100%;\n  &[data-no-scroll='true'] {\n    overflow-y: initial;\n  }\n`;\n//if we see this, then we havent shown user enough items - allow click to load more\nconst LoadMore = styled.div`\n  cursor: pointer;\n  text-decoration: underline;\n`;\nexport interface IInfiniteScroll {\n  children: any[];\n  className?: string;\n  startIndex?: number;\n  onScroll?: (e: { scrollTop: number; isDown: boolean }) => void;\n  /** how many to initially show, and to add per scroll. default 10 */\n  incrementNumber?: number;\n  /** if true, can only scroll by button press. default false */\n  scrollDisabled?: boolean;\n  /** eg 'showing x of y results' */\n  renderResultsLine?: (min: number, max: number) => React.ReactNode;\n}\nexport const InfiniteScroll = (p: IInfiniteScroll) => {\n  const { incrementNumber = 10, scrollDisabled = false } = p;\n  const ref = createRef<HTMLDivElement>();\n  const [startIndex] = useState(p.startIndex ?? 0);\n  const [endIndex, setEndIndex] = useState<number>(\n    startIndex + incrementNumber,\n  );\n  const [startScrollTop, setStartScrollTop] = useState(0);\n\n  const handleScrollTop = (e: React.UIEvent<HTMLDivElement>) => {\n    const { scrollTop, clientHeight, scrollHeight } = e.currentTarget;\n    const hasReachedEnd = scrollTop + clientHeight === scrollHeight;\n    if (hasReachedEnd) {\n      setEndIndex(endIndex + incrementNumber);\n    }\n  };\n  useEffect(() => {\n    setStartScrollTop(ref.current!.scrollTop);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const sliced = p.children.slice(0, endIndex);\n\n  const lastDisplayIndex = Math.min(p.children.length, endIndex);\n  const renderResultsLine = p.renderResultsLine?.(\n    lastDisplayIndex,\n    p.children.length,\n  );\n\n  return (\n    <Base\n      data-no-scroll={scrollDisabled}\n      ref={ref}\n      className={p.className}\n      onScroll={(e) => {\n        if (scrollDisabled) {\n          return;\n        }\n        const { scrollTop } = e.currentTarget;\n        handleScrollTop(e);\n        //\n        debounce(\n          () => {\n            setStartScrollTop(scrollTop);\n            p.onScroll?.({ scrollTop, isDown: startScrollTop < scrollTop });\n          },\n          {\n            key: 'in-scr',\n            time: 50,\n          },\n        );\n      }}\n      {...filterDataProps(p)}\n    >\n      {sliced}\n      {renderResultsLine}\n      {lastDisplayIndex < p.children.length && (\n        <LoadMore onClick={() => setEndIndex(endIndex + incrementNumber)}>\n          Load More?\n        </LoadMore>\n      )}\n    </Base>\n  );\n};\n","import styled from '@emotion/styled';\nimport type { CSSProperties } from 'react';\nimport React from 'react';\n\nconst CP = styled.div`\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: transparent;\n\n  &:before {\n    content: '';\n    position: relative;\n    display: block;\n    width: 150%;\n    height: 150%;\n    aspect-ratio: 4/3;\n    box-sizing: border-box;\n    border-radius: 45px;\n    background-color: var(--var-bg-col);\n    animation: pulse-ring 1s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;\n  }\n\n  @keyframes pulse-ring {\n    0% {\n      transform: scale(0.33);\n    }\n    80%,\n    100% {\n      opacity: 0;\n    }\n  }\n\n  @keyframes pulse-dot {\n    0% {\n      transform: scale(0.8);\n    }\n    50% {\n      transform: scale(1);\n    }\n    100% {\n      transform: scale(0.8);\n    }\n  }\n`;\n\nconst Text = styled.div`\n  position: absolute;\n  z-index: 1;\n  background-color: var(--var-bg-col);\n  border-radius: 15px;\n  box-shadow: 0 0 8px var(--var-bg-col);\n  min-width: 1rem;\n  min-height: 1rem;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  padding: 2px;\n`;\nexport const PulseRing = ({\n  style,\n  className,\n  text,\n  title,\n}: {\n  /** tooltip text */\n  title?: string;\n  /** bubble text */\n  text?: string;\n  className?: string;\n  style?: CSSProperties & {\n    /** default 2.5rem */\n    width?: string;\n    /** default 2.5rem */\n    height?: string;\n    /** colour of pulse. default #01a4e9 */\n    backgroundColor?: string;\n    /** colour of tex. default #000 */\n    color?: string;\n  };\n}) => {\n  const st: CSSProperties & {\n    //pulse color\n    '--var-bg-col': string;\n  } = {\n    ...style,\n    width: style?.width ?? '2rem',\n    height: style?.height ?? '2rem',\n    color: 'transparent',\n    backgroundColor: 'transparent',\n    '--var-bg-col': style?.backgroundColor ?? '#01a4e9',\n  };\n  return (\n    <CP style={st} className={className} title={title}>\n      <Text\n        style={{\n          color: style?.color ?? 'black',\n          aspectRatio: '1/1',\n          minWidth: '1.5ch',\n          minHeight: '1.5ch',\n        }}\n      >\n        {text}\n      </Text>\n    </CP>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport type { CSSProperties, ReactNode } from 'react';\nimport React from 'react';\n\nimport { bigScreen, smallScreen, vSmallScreen } from '../../styles/media';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: row;\n  flex-grow: 1;\n  width: 100%;\n  @media ${bigScreen} {\n    &[data-nowrap='true'] {\n      flex-flow: row;\n    }\n  }\n  &[data-break='small'] {\n    @media ${smallScreen} {\n      flex-flow: column;\n    }\n  }\n\n  &[data-break='vsmall'] {\n    @media ${vSmallScreen} {\n      flex-flow: column;\n    }\n  }\n\n  &[data-center='true'] {\n    justify-content: center;\n    align-items: center;\n  }\n  &[data-nogrow='true'] {\n    flex-grow: 0;\n    width: auto;\n  }\n`;\nexport interface IRowOrColumn {\n  noGrow?: boolean;\n  center?: boolean;\n  noWrap?: boolean;\n  children: ReactNode;\n  className?: string;\n  break?: 'small' | 'vsmall';\n  style?: CSSProperties;\n  onClick?: () => void;\n}\nexport type IFlexColumn = IRowOrColumn;\nexport type IFlexRow = IRowOrColumn;\nexport const RowOrColumn = (props: IRowOrColumn) => (\n  <Base\n    data-nogrow={props.noGrow ?? false}\n    data-center={props.center ?? false}\n    data-nowrap={props.noWrap ?? false}\n    {...props}\n    data-break={props.break ?? 'small'}\n  >\n    {props.children}\n  </Base>\n);\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { useState } from 'react';\n\nimport { Chevron } from '../Chevron';\n\nconst SBase = styled.div``;\nconst SSubTitle = styled.div`\n  font-size: 1rem;\n  font-weight: bold;\n  text-align: center;\n  margin-right: 0.5rem;\n`;\n\nconst SRollUpRow = styled.div`\n  display: flex;\n  cursor: pointer;\n`;\nexport interface IAccordion {\n  children: string | React.ReactNode;\n  title: string;\n  /** controlled component if provided */\n  open?: boolean;\n  /** called when openness changes */\n  setOpen?: (open: boolean) => void;\n  chevronColour?: string;\n  className?: string;\n}\n\nexport const Accordion = ({\n  title,\n  children,\n  open,\n  setOpen,\n  chevronColour = 'white',\n  className,\n}: IAccordion) => {\n  const [openSt, setOpenSt] = useState(false);\n  const controlled = open !== undefined;\n\n  return (\n    <SBase className={className}>\n      <SRollUpRow\n        onClick={() => {\n          setOpen?.(controlled ? !open : !openSt);\n          if (!controlled) {\n            setOpenSt(!openSt);\n          }\n        }}\n      >\n        <SSubTitle>{title}</SSubTitle>\n        <Chevron point={openSt ? 'up' : 'down'} colour={chevronColour} />\n      </SRollUpRow>\n\n      {(controlled ? open : openSt) && children}\n    </SBase>\n  );\n};\n","import styled from '@emotion/styled';\nimport type { MouseEventHandler } from 'react';\nimport React from 'react';\n\nimport type { IVarStyles } from '../../styles';\nimport { HardOutlineFilter } from '../../styles';\nimport type { IBarChartData } from './types';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: row;\n  width: 100%;\n  height: 100%;\n  cursor: default;\n  position: relative;\n`;\n\nconst Title = styled.div`\n  position: absolute;\n  left: 0.25rem;\n`;\n\nexport const Item = ({\n  data,\n  className,\n  onMouseMove,\n  onMouseLeave,\n  maxWidth,\n  style,\n}: {\n  data: IBarChartData;\n  className?: string;\n  onMouseMove?: MouseEventHandler<HTMLDivElement>;\n  onMouseLeave?: MouseEventHandler<HTMLDivElement>;\n  maxWidth: number;\n  style: IVarStyles;\n}) => (\n  <Base\n    className={className}\n    onMouseMove={onMouseMove}\n    onMouseLeave={onMouseLeave}\n    style={style}\n    data-type=\"bcb-item\"\n  >\n    <Title\n      style={{\n        color: style.color,\n        filter: HardOutlineFilter(style.backgroundColor),\n      }}\n    >\n      {data.name}\n    </Title>\n    {data.values.map((v) => (\n      <div\n        data-barchartitem-key={v.name}\n        key={v.name}\n        style={{\n          height: '100%',\n          width: `${(v.value / maxWidth) * 100}%`,\n          backgroundColor: v.colour,\n        }}\n      >\n        &nbsp;\n      </div>\n    ))}\n    <div\n      style={{\n        height: '100%',\n        flexGrow: 1,\n        backgroundColor: 'transparent',\n      }}\n    >\n      &nbsp;\n    </div>\n  </Base>\n);\n","import styled from '@emotion/styled';\nimport React from 'react';\n\nimport { distinctBy, flat } from '../../../common/helpers/array';\nimport type { IVarStyles } from '../../styles/common';\nimport { getLegendItems } from './getLegendItems';\nimport type { IBarChartData } from './types';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: column;\n`;\n\nconst Bar = styled.div`\n  width: 100%;\n  height: 1rem;\n  display: flex;\n  flex-flow: row;\n  position: relative;\n  margin-bottom: 0.25rem;\n`;\nconst Line = styled.div`\n  position: absolute;\n  top: calc(50% - 1px);\n  height: 2px;\n  left: 0;\n  right: 0;\n`;\n\nconst Numbers = styled.div`\n  width: 100%;\n  height: 1rem;\n  display: flex;\n  flex-flow: row;\n  justify-content: space-between;\n  z-index: 1;\n`;\n\nconst Items = styled.div`\n  width: 100%;\n  display: flex;\n  flex-flow: row wrap;\n  position: relative;\n  justify-content: space-between;\n`;\nconst Item = styled.div`\n  display: flex;\n  flex-flow: row;\n  position: relative;\n  align-items: center;\n  flex-basis: 25%;\n`;\n\nconst Col = styled.div`\n  width: 1rem;\n  height: 1rem;\n  border-radius: 50%;\n  margin-right: 0.25rem;\n`;\n\nexport const Legend = ({\n  data,\n  maxWidth,\n  style,\n}: {\n  data: IBarChartData[];\n  maxWidth: number;\n  style: IVarStyles;\n}) => {\n  const items = [0];\n  if (maxWidth > 10) {\n    items.push(Math.floor(maxWidth * 0.25));\n    items.push(Math.floor(maxWidth * 0.5));\n    items.push(Math.floor(maxWidth * 0.75));\n  }\n  items.push(maxWidth);\n\n  const keys = distinctBy(\n    flat(\n      data.map((data) => {\n        return getLegendItems({ data }).part.map((v) => ({\n          colour: v.colour,\n          name: v.name,\n        }));\n      }),\n    ),\n    (s) => s.name,\n  ).sort((a, b) => (a.name < b.name ? -1 : 1));\n\n  return (\n    <Base style={style}>\n      <Bar>\n        <Line\n          style={{ background: style.backgroundColor, color: style.color }}\n        />\n        <Numbers>\n          {items.map((i) => (\n            <span\n              style={{\n                backgroundColor: style.backgroundColor,\n                color: style.color,\n              }}\n              key={i}\n            >\n              {i}\n            </span>\n          ))}\n        </Numbers>\n      </Bar>\n      {keys.length > 1 && (\n        <Items>\n          {keys.map((k) => (\n            <Item key={k.name}>\n              <Col style={{ backgroundColor: k.colour }} />\n              {k.name}\n            </Item>\n          ))}\n        </Items>\n      )}\n    </Base>\n  );\n};\n","import styled from '@emotion/styled';\nimport React from 'react';\n\nimport type { IVarStyles } from '../../styles/common';\nimport { getLegendItems } from './getLegendItems';\nimport type { IBarChartData } from './types';\n\nconst Base = styled.div`\n  padding: 0.5rem;\n`;\n\nconst Title = styled.div`\n  font-weight: bold;\n`;\nconst Row = styled.div`\n  width: 100%;\n  display: flex;\n`;\n\nconst ItemTitle = styled.span`\n  &[data-selected='true'] {\n    font-weight: bold;\n    text-decoration: underline;\n  }\n`;\nconst Total = styled.span`\n  margin-left: auto;\n  padding-left: 0.5rem;\n\n  &[data-selected='true'] {\n    font-weight: bold;\n    text-decoration: underline;\n  }\n`;\n\nexport const TooltipContent = ({\n  data,\n  selectedKey,\n  style,\n}: {\n  data: IBarChartData;\n  selectedKey?: string;\n  style: IVarStyles;\n}) => {\n  const { part, rest, restTotal } = getLegendItems({ data, selectedKey });\n\n  return (\n    <Base\n      style={{\n        ...style,\n        border: `solid 1px ${style.borderColor}`,\n      }}\n    >\n      <Title>{data.name}</Title>\n      <Row>\n        <span>total</span>\n        <Total>{data.total}</Total>\n      </Row>\n      {part.map((v) => (\n        <Row style={{ color: v.colour }} key={v.name}>\n          <ItemTitle data-selected={selectedKey === v.name}>{v.name}</ItemTitle>\n          <Total data-selected={selectedKey === v.name}>{v.value}</Total>\n        </Row>\n      ))}\n      {rest.length > 0 && (\n        <Row>\n          <span>{rest.length} more</span>\n          <Total>{restTotal}</Total>\n        </Row>\n      )}\n    </Base>\n  );\n};\n","import styled from '@emotion/styled';\nimport React from 'react';\n\nimport { useTooltip } from '../../helpers/useTooltip';\nimport { getVarStyles, type IVarStyles } from '../../styles/common';\nimport { Item } from './Item';\nimport { Legend } from './Legend';\nimport { TooltipContent } from './TooltipContent';\nimport type { IBarChartData } from './types';\n\nconst BarChartBase = styled.div`\n  display: flex;\n  flex-flow: column;\n  width: 100%;\n  height: 100%;\n  margin-top: 0.5rem;\n  position: relative;\n`;\n\nconst ItemStyled = styled(Item)`\n  margin-bottom: 0.75rem;\n\n  &:last-of-type {\n    margin-bottom: 0;\n  }\n`;\n\nexport const BarChart = ({\n  data: dataRaw,\n  style: sRaw,\n  className,\n}: {\n  data: IBarChartData[];\n  style?: Partial<IVarStyles>;\n  className?: string;\n}) => {\n  const style = getVarStyles(sRaw);\n  const UT = useTooltip<{ selectedKey?: string; data: IBarChartData }>();\n\n  const maxWidth = Math.max(...dataRaw.map((a) => a.total));\n\n  return (\n    <BarChartBase data-type=\"bcb\" style={style} className={className}>\n      <UT.Comp pos={UT.pos}>\n        {({ data }) => <TooltipContent {...data} style={style} />}\n      </UT.Comp>\n      {dataRaw.map((data) => (\n        <ItemStyled\n          style={style}\n          key={data.name}\n          data={data}\n          maxWidth={maxWidth}\n          onMouseLeave={() => UT.setPos(undefined)}\n          onMouseMove={(element) => {\n            const selectedKey =\n              document\n                .elementFromPoint(element.pageX, element.pageY)\n                ?.getAttribute('data-barchartitem-key') ?? '';\n            UT.setPos({\n              element,\n              parent: element.currentTarget.closest(\"[data-type='bcb']\"),\n              data: { selectedKey, data },\n            });\n          }}\n        />\n      ))}\n      <Legend data={dataRaw} maxWidth={maxWidth} style={style} />\n    </BarChartBase>\n  );\n};\n","'use client';\nimport { css } from '@emotion/react';\nimport styled from '@emotion/styled';\nimport type { CSSProperties } from 'react';\nimport React from 'react';\n\nimport { removeUndefValuesFromObject } from '../../../common/helpers/object';\nimport { colours } from '../../styles/colours';\n\nconst BGcss = css`\n  max-height: calc(100% - 6px);\n  display: flex;\n  border: 0;\n  padding: 3px;\n  background-image:\n    linear-gradient(white, white),\n    linear-gradient(to bottom right, var(--left), var(--right));\n  background-origin: border-box;\n  background-clip: content-box, border-box;\n  overflow: hidden;\n  &[data-ccnd='true'] {\n    &:hover {\n      filter: saturate(3);\n    }\n  }\n`;\n\nconst BGLink = styled.div`\n  ${BGcss};\n`;\n\nconst BGALink = styled.a`\n  ${BGcss};\n`;\n\nconst Padding = styled.div`\n  justify-content: center;\n  align-items: center;\n  display: flex;\n  flex-flow: column;\n  border: 0;\n  flex-grow: 1;\n`;\n\nconst FeatureBoxFill = styled(Padding)`\n  background-image: linear-gradient(to bottom right, var(--left), var(--right));\n  color: ${colours.mainLight};\n  flex-grow: 1;\n`;\ntype IOnClick =\n  | React.MouseEvent<HTMLDivElement, MouseEvent>\n  | React.MouseEvent<HTMLAnchorElement, MouseEvent>;\n\nexport interface IBorderGradient {\n  canClick?: boolean;\n  noGrow?: boolean;\n  className?: string;\n  fill?: boolean;\n  /** default 2rem */\n  radius?: string;\n  left?: string;\n  right?: string;\n  children: React.ReactNode;\n  padding?: string;\n  onClick?: (e: IOnClick) => void;\n  href?: string;\n  target?: string;\n  rel?: string;\n  disabled?: boolean;\n}\nexport const BorderGradient = ({\n  left = colours.orange,\n  right = colours.orangeRed,\n  children,\n  radius = '2rem',\n  fill = false,\n  padding = '2rem',\n  className,\n  onClick,\n  href,\n  target,\n  rel,\n  noGrow = false,\n  disabled = false,\n  canClick = false,\n}: IBorderGradient) => {\n  const CCND = canClick && !disabled;\n  const style: CSSProperties = removeUndefValuesFromObject({\n    flexGrow: noGrow ? 0 : 1,\n    '--left': left,\n    '--right': right,\n    borderRadius: radius,\n    filter: !disabled ? null : 'grayscale(1)',\n    cursor: CCND ? 'pointer' : 'default',\n  });\n\n  const props = {\n    onClick: (e: IOnClick) => !disabled && onClick && onClick(e),\n    className,\n    href,\n    target,\n    rel,\n    canClick: !!onClick || canClick,\n    style,\n    'data-ccnd': CCND,\n  };\n\n  const child = (\n    <>\n      {!fill && <Padding style={{ padding }}>{children}</Padding>}\n      {fill && <FeatureBoxFill style={{ padding }}>{children}</FeatureBoxFill>}\n    </>\n  );\n\n  if (href) {\n    return <BGALink {...props}>{child}</BGALink>;\n  }\n  return <BGLink {...props}>{child}</BGLink>;\n};\n","'use client';\n\nimport { css } from '@emotion/react';\nimport type { StyledComponent } from '@emotion/styled';\nimport styled from '@emotion/styled';\nimport type { JSX, KeyboardEventHandler, MouseEventHandler } from 'react';\nimport React from 'react';\n\nimport { colours } from '../../styles/colours';\n\nexport const ButtonBase = css`\n  text-decoration: none;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border: 0;\n  font-weight: bold;\n  font-family: inherit;\n  font-size: 1.2rem;\n  border-radius: 0.5rem;\n  cursor: pointer;\n  height: 3rem;\n  line-height: 1rem;\n  &:hover {\n    filter: saturate(1.5);\n  }\n  padding-left: 1rem;\n  padding-right: 1rem;\n  color: white;\n\n  &[data-disabled='true'] {\n    cursor: default !important;\n    background-color: #888 !important;\n  }\n\n  &[data-theme='green'] {\n    background-color: ${colours.darkGreen};\n    &[data-invert='true'] {\n      color: ${colours.darkGreen};\n      background-color: white;\n      border: solid 1px ${colours.darkGreen};\n    }\n  }\n\n  &[data-theme='red'] {\n    background-color: ${colours.orangeRed};\n    &[data-invert='true'] {\n      color: ${colours.orangeRed};\n      background-color: white;\n      border: solid 1px ${colours.orangeRed};\n    }\n  }\n`;\n\nconst BaseButton = styled.button`\n  ${ButtonBase}\n`;\n\nconst BaseA = styled.a`\n  ${ButtonBase}\n`;\n\nexport interface IButton {\n  title?: string;\n  invert?: boolean;\n  disabled?: boolean;\n  className?: string;\n  onClick?: MouseEventHandler<HTMLButtonElement>;\n  onKeyDown?: KeyboardEventHandler<HTMLButtonElement>;\n  children: string | JSX.Element;\n  href?: string;\n  colourTheme?: 'green' | 'red';\n}\nexport const Button = (props: IButton) => {\n  const Component: StyledComponent<'button', any> = props.href\n    ? (BaseA as any)\n    : BaseButton;\n\n  return (\n    <Component\n      className={props.className}\n      data-invert={props.invert}\n      data-disabled={props.disabled ?? false}\n      role=\"button\"\n      title={props.title || undefined}\n      data-theme={props.colourTheme ?? 'green'}\n      {...props}\n    >\n      {props.children}\n    </Component>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React from 'react';\n\nimport { Button } from '../Button';\nimport { FlexColumn } from '../FlexColumn';\nimport { FlexRow } from '../FlexRow';\nimport { Modal } from '../Modal/Modal';\nimport type { IConfirmModal } from './types';\n\nconst Base = styled.div`\n  width: 95vw;\n  max-width: 30rem;\n  height: 50vh;\n  max-height: 15rem;\n`;\n\nconst Content = styled(FlexColumn)`\n  padding: 1rem;\n  height: calc(100% - 2rem);\n  width: calc(100% - 2rem);\n`;\n\nconst TopText = styled.div`\n  font-weight: bold;\n  border-bottom: solid 1px #ccc;\n  padding-bottom: 0.25rem;\n  font-size: 1.5rem;\n  margin-bottom: 1rem;\n`;\n\nconst BottomText = styled.div`\n  padding-bottom: 0.25rem;\n  font-size: 1.1rem;\n`;\n\nconst Bottom = styled(FlexRow)`\n  margin-top: auto;\n  justify-content: flex-end;\n  > button:first-of-type {\n    margin-right: 1rem;\n  }\n`;\n\nexport const ConfirmModal = ({\n  onSubmit,\n  bottomText,\n  topText,\n  okText = 'OK',\n  cancelText = 'Cancel',\n  style,\n}: IConfirmModal) => {\n  return (\n    <Modal\n      position=\"center\"\n      topPosition=\"center\"\n      open={true}\n      setOpen={() => onSubmit(false)}\n      showCloseButton={false}\n      closeOnClickOutside={false}\n    >\n      <Base>\n        <Content style={style}>\n          {topText && <TopText>{topText}</TopText>}\n          <BottomText>{bottomText}</BottomText>\n          <Bottom noGrow>\n            <Button onClick={() => onSubmit(true)}>{okText}</Button>\n            <Button invert onClick={() => onSubmit(false)}>\n              {cancelText}\n            </Button>\n          </Bottom>\n        </Content>\n      </Base>\n    </Modal>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport type { CSSProperties, Dispatch, JSX, SetStateAction } from 'react';\nimport React, { useState } from 'react';\n\nimport { useCookie } from '../../helpers/cookie/use';\nimport { Computer, Moon, Sun } from '../../icons';\nimport { FlexColumn } from '../FlexColumn';\nimport { Icon } from '../Icon';\nimport { TDarkMode, TDarkModeCalc } from './types';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: row;\n  &[data-mode='vert'] {\n    flex-flow: column;\n  }\n  overflow: hidden;\n  justify-content: space-between;\n  border-radius: 2rem;\n`;\n\nconst IconStyled = styled(Icon)`\n  > svg {\n    height: 60%;\n  }\n`;\n\nconst Label = styled(FlexColumn)`\n  border-radius: 50%;\n  overflow: hidden;\n  cursor: pointer;\n\n  &[data-selected='true'] {\n    background-color: white;\n    cursor: default;\n  }\n`;\n\nconst getColours = (p: TDarkMode, vert: boolean) => {\n  const deg = vert ? '180deg' : '90deg';\n  switch (p) {\n    case TDarkMode.dark: {\n      const d1 = 'rgba(173,128,227,1)';\n      const d2 = 'rgba(106,44,181,1)';\n      return [d1, `linear-gradient(${deg}, ${d1} 0%, ${d2} 76%)`];\n    }\n    case TDarkMode.light: {\n      const l1 = 'rgba(255,169,54,1)';\n      const l2 = 'rgba(255,189,100,1)';\n      return [l1, `linear-gradient(${deg}, ${l1} 0%, ${l2} 76%)`];\n    }\n    case TDarkMode.system: {\n      return ['green', 'green'];\n    }\n  }\n};\n\nconst modes: {\n  mode: TDarkMode;\n  icon: (p: { style: { fill: string } }) => JSX.Element;\n}[] = [\n  { mode: TDarkMode.dark, icon: Moon },\n  { mode: TDarkMode.system, icon: Computer },\n  { mode: TDarkMode.light, icon: Sun },\n];\n\nexport interface IDarkMode {\n  onSubmit?: (p: TDarkMode) => void;\n  /** default horiz */\n  mode?: 'vert' | 'horiz';\n  /** default 2.5rem */\n  iconSize?: string;\n  className?: string;\n  style?: CSSProperties;\n  cookieDocument: string;\n}\n\nexport interface IUseDarkMode {\n  darkmode: TDarkMode;\n  setDarkmode: Dispatch<SetStateAction<TDarkMode>>;\n  /** converts system to the required output */\n  calcDarkMode: () => TDarkModeCalc;\n}\n\nexport const UseDarkMode = ({\n  cookieDocument,\n}: {\n  cookieDocument: string;\n}): IUseDarkMode => {\n  const [darkmode, setDarkmode] = useCookie<TDarkMode>({\n    defaultValue: TDarkMode.system,\n    name: 'darkmode',\n    cookieDocument,\n    parse: (v) => Number(v) as TDarkMode,\n    stringify: (v) => v.toString(),\n  });\n\n  const calcDarkMode = (): TDarkModeCalc => {\n    const isDarkMode = window.matchMedia(\n      '(prefers-color-scheme: dark)',\n    ).matches;\n\n    if (darkmode === TDarkMode.system) {\n      return isDarkMode ? TDarkModeCalc.dark : TDarkModeCalc.light;\n    }\n\n    return darkmode === TDarkMode.dark\n      ? TDarkModeCalc.dark\n      : TDarkModeCalc.light;\n  };\n\n  return {\n    darkmode,\n    setDarkmode,\n    calcDarkMode,\n  };\n};\n\n/** shows darkmode toggle. Persists to cookie, and modifies html classList with either dark-mode or light-mode\n * this method has the darkmode passed in, so UseDarkMode can be used globally\n */\nexport const DarkModeAux = ({\n  iconSize = '2.5rem',\n  className,\n  mode,\n  onSubmit,\n  style,\n  dm,\n}: IDarkMode & {\n  dm: IUseDarkMode;\n}) => {\n  const [index, setIndex] = useState<number>(\n    modes.findIndex((d) => d.mode === dm.darkmode),\n  );\n  const [fill, background] = getColours(modes[index].mode, mode === 'vert');\n  const twCalc = `calc(${iconSize} + ${iconSize} + ${iconSize} )`;\n  const setDarkmode = (newDarkMode: TDarkMode) => {\n    let className = '';\n    if (newDarkMode === TDarkMode.dark) {\n      className += 'dark-mode';\n    } else if (newDarkMode === TDarkMode.light) {\n      className += 'light-mode';\n    } else {\n      className = '';\n    }\n    try {\n      document.getElementsByTagName('html')[0].classList.remove('dark-mode');\n      document.getElementsByTagName('html')[0].classList.remove('light-mode');\n      if (className) {\n        document.getElementsByTagName('html')[0].classList.add(className);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (e) {\n      //\n    }\n\n    dm.setDarkmode(newDarkMode);\n    onSubmit?.(newDarkMode);\n  };\n\n  return (\n    <Base\n      className={className}\n      data-mode={mode ?? 'horiz'}\n      style={{\n        ...style,\n        background,\n        border: `solid 2px ${fill}`,\n        width: twCalc,\n        height: iconSize,\n\n        ...(mode === 'vert' && {\n          width: iconSize,\n          height: twCalc,\n        }),\n      }}\n    >\n      {modes.map((v, i) => {\n        const selected = index === i;\n        return (\n          <Label\n            data-selected={selected}\n            style={{ width: iconSize, height: iconSize }}\n            // eslint-disable-next-line react/no-array-index-key\n            key={i.toString()}\n            onClick={() => {\n              if (index === i) {\n                return;\n              }\n              setIndex(i);\n              setDarkmode(v.mode);\n            }}\n          >\n            <IconStyled>\n              {v.icon({ style: { fill: selected ? fill : 'white' } })}\n            </IconStyled>\n          </Label>\n        );\n      })}\n    </Base>\n  );\n};\n\n/** shows darkmode toggle. Persists to cookie, and modifies html classList with either dark-mode or light-mode */\nexport const DarkMode = (p: IDarkMode) => {\n  const dm = UseDarkMode({ cookieDocument: p.cookieDocument });\n  return DarkModeAux({ ...p, dm });\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React from 'react';\n\nimport type { IFlexColumn } from '../RowOrColumn';\n\nconst Base = styled.div`\n  position: relative;\n  display: flex;\n  flex-flow: column;\n  flex-grow: 1;\n  width: 100%;\n  height: 100%;\n  &[data-center='true'] {\n    justify-content: center;\n    align-items: center;\n  }\n  &[data-nogrow='true'] {\n    flex-grow: 0;\n    width: unset;\n    height: unset;\n  }\n`;\n\nexport const FlexColumn = (props: IFlexColumn) => (\n  <Base\n    data-nogrow={props.noGrow ?? false}\n    data-center={props.center ?? false}\n    {...props}\n  >\n    {props.children}\n  </Base>\n);\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { useEffect, useState } from 'react';\n\nconst Base = styled.div`\n  border: 16px solid #f3f3f3; /* Light grey */\n  border-top: 16px solid #3498db; /* Blue */\n  border-radius: 50%;\n  animation: spin 2s linear infinite;\n  padding: 2px;\n  overflow: hidden;\n\n  @keyframes spin {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n`;\n\nconst LoadingBack = styled.div`\n  position: absolute;\n  &[data-type='abs'] {\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n  }\n  &[data-type='br'] {\n    bottom: 1rem;\n    right: 1rem;\n    top: auto;\n  }\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 100;\n  background-color: transparent;\n  opacity: 1;\n  &[data-transparent='true'] {\n    opacity: 0.1;\n  }\n  transition: opacity 5s;\n`;\n\nexport interface ILoader {\n  /**\n   * default 2rem\n   */\n  width?: string | null;\n  /**\n   * default 2rem\n   */\n  height?: string | null;\n  name: string;\n  /** position for loader. default full page takeover */\n  position?: 'abs' | 'br';\n}\nexport const Loader = ({\n  name,\n  height = '2rem',\n  width = '2rem',\n  position = 'abs',\n}: ILoader) => {\n  const [trans, setTrans] = useState(true);\n  useEffect(() => {\n    setTrans(false);\n  }, []);\n\n  return (\n    <LoadingBack\n      data-loading={name}\n      data-transparent={trans}\n      data-type={position}\n    >\n      <Base style={{ height: height as string, width: width as string }} />\n    </LoadingBack>\n  );\n};\n","import styled from '@emotion/styled';\nimport type { JSX } from 'react';\nimport React from 'react';\n\nimport { hashCode } from '../../../common';\nimport { insertElementAtIndex } from '../../../common/helpers/array';\nimport { trimSide } from '../../../common/helpers/string/trim';\n\nconst injectTable = ({\n  tableRows,\n  preprocessText,\n}: {\n  tableRows: string[];\n  preprocessText: (s: string) => string | JSX.Element;\n}) => (\n  <table key={hashCode(JSON.stringify(tableRows))}>\n    <thead>\n      <tr>\n        {tableRows[0]\n          .split('|')\n          .map((header) => header.trim())\n          .map((header) => (\n            <th key={header}>{preprocessText(header)}</th>\n          ))}\n      </tr>\n    </thead>\n    <tbody>\n      {tableRows.slice(2).map((row) => {\n        const cells = row.split('|').map((cell) => cell.trim());\n        return (\n          <tr key={row}>\n            {cells.map((cell) => (\n              <td key={cell}>{preprocessText(cell)}</td>\n            ))}\n          </tr>\n        );\n      })}\n    </tbody>\n  </table>\n);\n\nconst injectGroup = ({\n  output,\n  pos,\n  wrap,\n}: {\n  pos: {\n    outputIndex: number;\n    matchLine: string;\n  };\n  output: JSX.Element[];\n  wrap: (items: JSX.Element[]) => JSX.Element;\n}) => {\n  const outputEndIndex = output.length;\n  const sum: JSX.Element[] = [];\n\n  for (let a = pos.outputIndex; a <= outputEndIndex; a += 1) {\n    sum.push(output[a]);\n    delete output[a];\n  }\n  output = insertElementAtIndex(output, wrap(sum), pos.outputIndex);\n  return output;\n};\n\nfunction renderMarkdown({\n  markdown,\n  preprocessText = (s) => s,\n}: {\n  preprocessText?: (s: string) => string | JSX.Element;\n  markdown: string;\n}) {\n  const lines = markdown.split('\\n');\n  let output: JSX.Element[] = [];\n\n  let ol: { outputIndex: number; matchLine: string } | undefined;\n  let ul: { outputIndex: number; matchLine: string } | undefined;\n  let tableRows: string[] = [];\n  let a = -1;\n  do {\n    a += 1;\n    const line = lines[a] ?? '';\n    const la = line + a;\n\n    const star = /\\*\\*(.*?)\\*\\*/gim;\n    //handle inline **s\n    if (line.match(star)) {\n      output.push(\n        <p\n          key={la}\n          dangerouslySetInnerHTML={{\n            __html: line.replace(star, `<b>$1</b>`).trim(),\n          }}\n        />,\n      );\n      continue;\n    }\n\n    //table\n    if (line.startsWith('|')) {\n      tableRows.push(line);\n      continue;\n    } else {\n      if (tableRows.length > 0) {\n        output.push(injectTable({ tableRows, preprocessText }));\n        tableRows = [];\n      }\n    }\n    //ol\n    if (line.match(/^[0-9]+\\./gim)) {\n      if (ol === undefined) {\n        ol = { matchLine: line, outputIndex: output.length };\n      }\n    } else if (ol && ol.matchLine !== line) {\n      output = injectGroup({\n        output,\n        pos: ol,\n        wrap: (i) => <ol key={i[0].key}>{i}</ol>,\n      });\n      ol = undefined;\n    }\n\n    //ul\n    if (line.startsWith('-') || line.startsWith('*')) {\n      if (ul === undefined) {\n        ul = { matchLine: line, outputIndex: output.length };\n      }\n    } else if (ul && ul.matchLine !== line) {\n      output = injectGroup({\n        output,\n        pos: ul,\n        wrap: (i) => <ul key={i[0].key}>{i}</ul>,\n      });\n      ul = undefined;\n    }\n\n    // h1\n    if (line.startsWith('#')) {\n      const level = line.match(/^#+/)?.[0]?.length ?? 0;\n      const t = trimSide(line, true, '#').trim();\n      if (level === 1) {\n        output.push(<h1 key={t}>{preprocessText(t)}</h1>);\n      } else if (level === 2) {\n        output.push(<h2 key={t}>{preprocessText(t)}</h2>);\n      } else if (level === 3) {\n        output.push(<h3 key={t}>{preprocessText(t)}</h3>);\n      } else if (level === 4) {\n        output.push(<h4 key={t}>{preprocessText(t)}</h4>);\n      } else if (level === 5) {\n        output.push(<h5 key={t}>{preprocessText(t)}</h5>);\n      } else if (level >= 6) {\n        output.push(<h6 key={t}>{preprocessText(t)}</h6>);\n      }\n    }\n    //ul - li\n    else if (line.startsWith('*') || line.startsWith('-')) {\n      const t = line.slice(2).trim();\n      if (t.length > 0) {\n        output.push(<li key={t}>{preprocessText(t)}</li>);\n      }\n    }\n    //ol - li\n    else if (line.match(/^[0-9]+\\./gim)) {\n      const t = line.slice(3).trim();\n      if (t.length > 0) {\n        output.push(<li key={t}>{preprocessText(t)}</li>);\n      }\n    }\n    //text\n    else {\n      if (line.length > 0) {\n        output.push(<p key={la}>{preprocessText(line)}</p>);\n      }\n    }\n  } while (a < lines.length);\n  return output;\n}\n\nconst Base = styled.div`\n  > * {\n    margin: 0;\n    white-space: pre-wrap;\n  }\n  ul {\n    display: grid;\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  ol,\n  ul,\n  table {\n    margin-bottom: 1rem;\n  }\n`;\n\nexport interface IMarkdown {\n  markdown: string;\n  className?: string;\n  /** run after html is generated for markdown, but before applied */\n  preprocessText?: (s: string) => string | JSX.Element;\n}\nexport const Markdown = (p: IMarkdown) => (\n  <Base className={p.className}>\n    {renderMarkdown({\n      preprocessText: p.preprocessText,\n      markdown: p.markdown.trim(),\n    })}\n  </Base>\n);\n","'use client';\nimport styled from '@emotion/styled';\nimport type { CSSProperties } from 'react';\nimport React, { useRef, useState } from 'react';\n\nimport { useOnClickOutside } from '../../helpers';\nimport { NoTextSelect } from '../../styles/common';\nimport { smallScreenPx } from '../../styles/media';\nimport { Chevron } from '../Chevron';\nimport { Icon } from '../Icon';\n\nconst Base = styled.div`\n  position: sticky;\n  top: 0;\n  border-right: solid 1px #ccc;\n  height: 100%;\n  ${NoTextSelect};\n  width: fit-content;\n`;\n\nconst Content = styled.div`\n  display: flex;\n  flex-flow: column;\n  width: 100%;\n  height: 100%;\n  > div {\n    flex-basis: 100%;\n  }\n`;\n\nconst OpenIcon = styled(Icon)`\n  width: 2rem;\n  height: 2rem;\n  margin: 0.5rem;\n  margin-left: auto;\n`;\n\nconst ChevronStyled = styled(Chevron)`\n  svg {\n    fill: #555;\n  }\n`;\n\nexport interface IMinSidebar {\n  children: ({\n    open,\n  }: {\n    /** can make sidebar contents smaller when open=false */\n    open: boolean;\n  }) => React.ReactNode;\n  className?: string;\n  /** default white */\n  chevronColour?: string;\n  style?: CSSProperties;\n}\nexport const MinSidebar = ({\n  chevronColour,\n  children,\n  className,\n  style,\n}: IMinSidebar) => {\n  const ref = useRef<HTMLDivElement>(null);\n  const [open, setOpen] = useState<boolean>(false);\n\n  useOnClickOutside(\n    { ref, disabled: () => !open || window.innerWidth > smallScreenPx },\n    () => {\n      setOpen(false);\n    },\n  );\n\n  return (\n    <Base\n      style={style}\n      data-type=\"sidebar\"\n      className={className}\n      data-open={open}\n      onClick={() => !open && setOpen(true)}\n      ref={ref}\n    >\n      <Content\n        data-type=\"content\"\n        data-open={open}\n        onClick={(e) => {\n          e.stopPropagation();\n        }}\n      >\n        <OpenIcon\n          onClick={(e) => {\n            e.stopPropagation();\n            setOpen(!open);\n          }}\n        >\n          <ChevronStyled\n            data-open={open}\n            point={open ? 'left' : 'right'}\n            width=\"100%\"\n            colour={chevronColour ?? 'white'}\n          />\n        </OpenIcon>\n        {children({ open })}\n      </Content>\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React from 'react';\n\nexport interface IPieChartData {\n  label: string;\n  value: number;\n  color: string;\n}\nexport interface IPieChart {\n  data: IPieChartData[];\n  className?: string;\n}\n\nconst Base = styled.div`\n  width: 100%;\n  height: 100%;\n`;\n\nexport const PieChart: React.FC<IPieChart> = ({ data, className }) => {\n  const total = data.reduce((sum, { value }) => sum + value, 0);\n  const width = 500;\n  const height = 500;\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(width, height) / 2;\n  let cumulativeAngle = 0;\n\n  return (\n    <Base className={className}>\n      <svg viewBox={`0 0 ${width} ${height}`}>\n        {data.map(({ label, value, color }) => {\n          const angle = (value / total) * 360;\n          const startX =\n            centerX + radius * Math.cos((cumulativeAngle * Math.PI) / 180);\n\n          const startY =\n            centerY + radius * Math.sin((cumulativeAngle * Math.PI) / 180);\n\n          const endX =\n            centerX +\n            radius * Math.cos(((cumulativeAngle + angle) * Math.PI) / 180);\n\n          const endY =\n            centerY +\n            radius * Math.sin(((cumulativeAngle + angle) * Math.PI) / 180);\n\n          const largeArcFlag = angle > 180 ? 1 : 0;\n          const midAngle = cumulativeAngle + angle / 2;\n          const midX =\n            centerX + radius * 0.75 * Math.cos((midAngle * Math.PI) / 180);\n\n          const midY =\n            centerY + radius * 0.75 * Math.sin((midAngle * Math.PI) / 180);\n\n          cumulativeAngle += angle;\n\n          return (\n            <g key={label}>\n              <title>{`${label}: ${value}`}</title>\n              <path\n                d={`M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY} L ${centerX} ${centerY} Z`}\n                fill={color}\n              />\n              <text\n                x={midX}\n                y={midY}\n                textAnchor=\"middle\"\n                alignmentBaseline=\"middle\"\n                stroke=\"white\"\n                strokeWidth=\"6px\"\n              >\n                {label}\n              </text>\n              <text\n                x={midX}\n                y={midY}\n                textAnchor=\"middle\"\n                alignmentBaseline=\"middle\"\n                fill=\"black\"\n              >\n                {label}\n              </text>\n            </g>\n          );\n        })}\n      </svg>\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { useEffect, useState } from 'react';\n\nimport { colours } from '../../styles';\n\nconst Base = styled.div`\n  position: relative;\n  min-width: 5rem;\n  width: 100%;\n  height: 2rem;\n  border-radius: 1rem;\n  overflow: hidden;\n`;\n\nconst Bar = styled.div`\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n`;\n\nconst Dot = styled.div`\n  position: absolute;\n  top: calc(50% - 0.25rem);\n  width: 0.5rem;\n  height: 0.5rem;\n  background-color: #aaa;\n  z-index: 1;\n  border-radius: 50%;\n  &[data-invert='true'] {\n    background-color: #333;\n  }\n`;\n\nexport interface IProgressBar {\n  min: number;\n  max: number;\n  /** default #4d76ff */\n  frontColour?: string;\n  /** default #eee */\n  backColour?: string;\n  /** default 25,50,75 */\n  dotPercentages?: number[] | null;\n  className?: string;\n  /** if true, will transition to the end in X ms */\n  transitionToMs?: number;\n}\n\nexport const ProgressBar = (p: IProgressBar) => {\n  const {\n    transitionToMs = 200,\n    frontColour = colours.notificationBlue,\n    backColour = '#eee',\n    dotPercentages = [25, 50, 75],\n  } = p;\n\n  const [barWidth, setBarWidth] = useState((p.min / p.max) * 100);\n  useEffect(() => {\n    const newbw = (p.min / p.max) * 100;\n    if (barWidth !== newbw) {\n      setBarWidth(newbw);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [p.min, p.max]);\n\n  useEffect(() => {\n    if (transitionToMs) {\n      setBarWidth(p.max);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return (\n    <Base\n      style={{\n        backgroundColor: backColour,\n      }}\n      className={p.className}\n    >\n      <Bar\n        style={{\n          width: `${barWidth}%`,\n          backgroundColor: frontColour,\n          transition: `width ${transitionToMs}ms linear`,\n        }}\n      />\n      {dotPercentages?.map((v) => (\n        <Dot\n          key={v}\n          style={{ left: `calc(${v}% - 0.25rem)` }}\n          data-invert={v > barWidth}\n        />\n      ))}\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { useState } from 'react';\n\nimport { Button } from '../Button';\nimport { FlexColumn } from '../FlexColumn';\nimport { FlexRow } from '../FlexRow';\nimport { Modal } from '../Modal/Modal';\nimport { TextEdit } from '../TextEdit';\nimport type { IPromptModal } from './types';\n\nconst Base = styled.div`\n  width: 95vw;\n  max-width: 30rem;\n  height: 50vh;\n  max-height: 15rem;\n`;\n\nconst Content = styled(FlexColumn)`\n  padding: 1rem;\n  height: calc(100% - 2rem);\n  width: calc(100% - 2rem);\n`;\n\nconst TopText = styled.div`\n  font-weight: bold;\n  border-bottom: solid 1px #ccc;\n  padding-bottom: 0.25rem;\n  font-size: 1.5rem;\n  margin-bottom: 1rem;\n`;\n\nconst BottomText = styled.div`\n  padding-bottom: 0.25rem;\n  font-size: 1.1rem;\n`;\n\nconst Bottom = styled(FlexRow)`\n  margin-top: auto;\n  justify-content: flex-end;\n  > button:first-of-type {\n    margin-right: 1rem;\n  }\n`;\nexport const PromptModal = ({\n  root,\n  wrapper,\n  res,\n  bottomText,\n  topText,\n  okText = 'OK',\n  cancelText = 'Cancel',\n  defaultValue,\n  placeholder,\n  style,\n}: IPromptModal) => {\n  const [text, setText] = useState(defaultValue || '');\n  const ret = (v: string | undefined) => {\n    try {\n      res(v);\n    } finally {\n      try {\n        root?.unmount();\n        wrapper?.remove();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (e) {\n        //\n      }\n    }\n  };\n\n  return (\n    <Modal\n      position=\"center\"\n      topPosition=\"center\"\n      open={true}\n      setOpen={() => ret(undefined)}\n      showCloseButton={false}\n      closeOnClickOutside={false}\n    >\n      <Base>\n        <Content style={style}>\n          {topText && <TopText>{topText}</TopText>}\n          <BottomText>{bottomText}</BottomText>\n          <TextEdit\n            defaultValue={text}\n            onSubmit={(c, enter) => {\n              if (enter) {\n                ret(c);\n              } else {\n                setText(c);\n              }\n            }}\n            placeholder={placeholder}\n            defaultEditing={{ focus: true }}\n            singleLine\n            noGrow\n            allowUndo={false}\n          />\n          <Bottom noGrow>\n            <Button onClick={() => ret(text)}>{okText}</Button>\n            <Button invert onClick={() => ret(undefined)}>\n              {cancelText}\n            </Button>\n          </Bottom>\n        </Content>\n      </Base>\n    </Modal>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport type { CSSProperties } from 'react';\nimport type { JSX } from 'react';\nimport React, { useState } from 'react';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: row;\n  &[data-mode='vert'] {\n    flex-flow: column;\n  }\n  overflow: hidden;\n  justify-content: space-between;\n`;\n\nconst Label = styled.label`\n  text-align: center;\n  display: flex;\n  align-items: center;\n\n  &[data-selected='true'] {\n    cursor: default;\n  }\n  &[data-selected='false'] {\n    cursor: pointer;\n  }\n`;\n\nexport interface IRadioGroup<T> {\n  /**\n   * can overload the render of the label. defaults to toString\n   */\n  renderLabel?: (a: T, selected: boolean) => JSX.Element;\n  defaultIndex: number;\n  onSubmit: (val: T, index: number) => void;\n  values: T[];\n  className?: string;\n  style?: CSSProperties;\n  /** default horiz */\n  mode?: 'vert' | 'horiz';\n}\n\nexport const RadioGroup = <T,>(p: IRadioGroup<T>) => {\n  const { renderLabel = (x) => (x as any).toString() } = p;\n  const [index, setIndex] = useState<number>(p.defaultIndex);\n\n  return (\n    <Base className={p.className} style={p.style} data-mode={p.mode ?? 'horiz'}>\n      {p.values.map((v, i) => (\n        <Label\n          // eslint-disable-next-line react/no-array-index-key\n          key={i.toString()}\n          data-selected={index === i}\n          onClick={() => {\n            if (index === i) {\n              return;\n            }\n            setIndex(i);\n            p.onSubmit(v, i);\n          }}\n        >\n          {renderLabel(v, index === i)}\n        </Label>\n      ))}\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { createRef, useState } from 'react';\n\nimport { useGranularEffect } from '../../helpers/useGranularHook';\nimport { CrossIcon, Magnify } from '../../icons';\nimport { bigScreen, smallScreen } from '../../styles';\nimport type { IRefTextEdit } from '../TextEdit';\nimport { SearchBox } from './SearchBox';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: row;\n  align-items: center;\n  margin-left: 1rem;\n\n  @media ${bigScreen} {\n    width: 20rem;\n  }\n`;\nconst Icon = styled.div`\n  display: flex;\n  margin-right: 0.5rem;\n  > svg {\n    width: 1.2rem;\n    height: 1.2rem;\n    fill: white;\n  }\n`;\nconst SearchBoxStyled = styled(SearchBox)`\n  transition: width 200ms ease-in-out;\n\n  overflow: hidden;\n  padding: 0;\n  &[data-open='false'] {\n    width: 0;\n    padding: 0;\n  }\n  @media ${smallScreen} {\n    padding: 0;\n  }\n`;\nexport interface IAutoHideSearchBox {\n  searchText: string;\n  setSearchText: (val: string, enterPressed: boolean) => void;\n  onOpenToggle?: (open: boolean) => void;\n  className?: string;\n}\nexport const AutoHideSearchBox = (p: IAutoHideSearchBox) => {\n  const [open, setOpen] = useState(!!p.searchText);\n\n  const textEditRef = createRef<IRefTextEdit>();\n\n  useGranularEffect(\n    () => {\n      const newOpen = !!p.searchText;\n      if (newOpen !== open) {\n        setOpen(!open);\n        p.onOpenToggle?.(!open);\n      }\n    },\n    [p.searchText],\n    [open],\n  );\n  return (\n    <Base className={p.className} data-open={open}>\n      <Icon\n        style={{ cursor: 'pointer' }}\n        onClick={() => {\n          if (open) {\n            p.setSearchText('', false);\n          }\n          setOpen(!open);\n          p.onOpenToggle?.(!open);\n          if (!open) {\n            setTimeout(() => textEditRef.current?.focus(), 100);\n          }\n        }}\n      >\n        {open && <CrossIcon />}\n        {!open && <Magnify style={{ fill: 'white' }} />}\n      </Icon>\n      <SearchBoxStyled\n        textBoxRef={textEditRef}\n        {...p}\n        data-open={open}\n        setSearchText={(val, enter) => {\n          //we dont want empty enters to do anything\n          if (val === '' && enter) {\n            p.setSearchText(val, false);\n          } else {\n            p.setSearchText(val, enter);\n          }\n        }}\n      />\n    </Base>\n  );\n};\n","'use client';\nimport { css } from '@emotion/react';\nimport styled from '@emotion/styled';\nimport React, { useRef, useState } from 'react';\n\nimport { useOnClickOutside } from '../../helpers';\nimport { Hamburger } from '../../icons/Hamburger';\nimport { NoTextSelect } from '../../styles/common';\nimport { bigScreen, smallScreen, smallScreenPx } from '../../styles/media';\nimport { Chevron } from '../Chevron';\n\nconst closedSidebarHover = css`\n  padding-left: 0.5rem;\n  width: 0.5rem;\n  background-color: rgba(0, 0, 0, 0.1);\n  cursor: pointer;\n  &:hover,\n  &:hover [data-hover='true'] {\n    background-color: #ccc;\n  }\n  &:hover {\n    border-right: solid 1px #999;\n  }\n`;\n\nconst Base = styled.div`\n  position: sticky;\n  top: 0;\n  transition: all 200ms;\n  border-right: solid 1px #ccc;\n  height: 100vh;\n  z-index: 1;\n\n  ${NoTextSelect};\n  &:hover {\n    [data-type='content-block'] {\n      left: 1rem;\n    }\n  }\n\n  &[data-open='true'] {\n    width: fit-content;\n\n    @media ${smallScreen} {\n      max-width: unset;\n      position: fixed;\n      top: 0;\n      left: 0;\n    }\n  }\n  &[data-open='false'] {\n    ${closedSidebarHover};\n  }\n\n  :not([data-open]) {\n    @media ${smallScreen} {\n      ${closedSidebarHover};\n    }\n    @media ${bigScreen} {\n      width: fit-content;\n    }\n  }\n`;\n\nconst closedContentBlockOffScreen = css`\n  left: -100vw;\n  transition: left 200ms;\n  height: 100%;\n`;\n\nconst ContentBlock = styled.div`\n  ${closedContentBlockOffScreen};\n  &[data-open='false'] {\n    position: absolute;\n    top: 0;\n    z-index: 1;\n    width: fit-content;\n  }\n\n  :not([data-open]) {\n    @media ${smallScreen} {\n      position: absolute;\n      ${closedContentBlockOffScreen};\n    }\n  }\n`;\n\nconst Content = styled.div`\n  display: flex;\n  flex-flow: column;\n  width: 100%;\n  height: 100%;\n\n  &[data-open='false'] {\n    filter: drop-shadow(1px 1px 0.5rem #555);\n    border-radius: 1rem;\n    background-color: rgba(255, 255, 255, 0.1);\n  }\n`;\n\nconst HamburgerB = styled.div`\n  position: absolute;\n  transition: all 200ms;\n  z-index: 2;\n\n  &[data-hide-on-big='true'] {\n    @media ${bigScreen} {\n      display: none;\n    }\n  }\n\n  &[data-open='false'] {\n    top: 0.5rem;\n    left: 0.25rem;\n  }\n\n  :not([data-open]) {\n    @media ${bigScreen} {\n      top: 0.5rem;\n      right: -0.75rem;\n    }\n  }\n  &[data-open='true'] {\n    top: 0.5rem;\n    right: -0.75rem;\n  }\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 1.5rem;\n  height: 1.5rem;\n  background-color: rgba(255, 255, 255, 0.9);\n  padding: 0.25rem;\n  &:hover {\n    background-color: rgba(255, 255, 255, 0.7);\n  }\n  border-radius: 50%;\n  border: solid 1px rgba(0, 0, 0, 0.5);\n  cursor: pointer;\n`;\n\nconst ChevronStyled = styled(Chevron)`\n  svg {\n    fill: #555;\n  }\n`;\n\nexport interface ISidebar {\n  children: React.ReactNode;\n  className?: string;\n  /** default:defaultClosed\n   * defaultClosed: always closed by default.\n   * fixedOpen: always open on bigscreen. cant close if bigscreen\n   */\n  mode?: 'defaultClosed' | 'fixedOpen';\n}\nexport const Sidebar = ({\n  children,\n  className,\n  mode = 'defaultClosed',\n}: ISidebar) => {\n  const ref = useRef<HTMLDivElement>(null);\n  const [open, setOpen] = useState<boolean | null>(\n    mode === 'defaultClosed' ? false : null,\n  );\n\n  useOnClickOutside(\n    { ref, disabled: () => !open || window.innerWidth > smallScreenPx },\n    () => {\n      setOpen(false);\n    },\n  );\n\n  return (\n    <Base\n      data-type=\"sidebar\"\n      className={className}\n      data-open={open}\n      onClick={() => !open && setOpen(true)}\n      data-hover\n      ref={ref}\n    >\n      <HamburgerB\n        data-hide-on-big={mode === 'fixedOpen'}\n        data-open={open}\n        onClick={(e) => {\n          e.stopPropagation();\n          setOpen(!open);\n        }}\n        data-hover\n      >\n        {open ? <ChevronStyled point=\"left\" width=\"100%\" /> : <Hamburger />}\n      </HamburgerB>\n      <ContentBlock data-type=\"content-block\" data-open={open}>\n        <Content\n          data-type=\"content\"\n          data-open={open}\n          onClick={(e) => {\n            e.stopPropagation();\n          }}\n        >\n          {children}\n        </Content>\n      </ContentBlock>\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React from 'react';\n\nimport { distinctBy } from '../../../common/helpers/array';\nimport { rangePercentage } from '../../../common/helpers/math';\n\nconst barWidth = 2;\nconst Base = styled.div`\n  width: calc(100% - 1px);\n  height: calc(100% - 1px);\n  border: solid 1px #666;\n  padding: 0;\n  display: flex;\n  justify-content: center;\n  align-items: flex-end;\n  overflow: hidden;\n`;\n\nconst Points = styled.div`\n  position: relative;\n  width: calc(100% - ${barWidth}px);\n  height: calc(100% - ${barWidth}px);\n  margin-left: ${barWidth}px;\n`;\n\nconst Point = styled.div`\n  position: absolute;\n  width: ${barWidth}px;\n`;\n\nexport interface ISparkLine {\n  /**\n   * default #4d76ff\n   */\n  pointColour?: string;\n  className?: string;\n  data: TSparkLineData[];\n  pointTitleF?: (p: TSparkLineData) => string;\n  title?: string;\n}\nexport type TSparkLineData = { x: number; y: number };\nexport const SparkLine = (p: ISparkLine) => {\n  const { data: raw, pointColour = '#4d76ff' } = p;\n  const xMin = Math.min(...raw.map((d) => d.x));\n  const xMax = Math.max(...raw.map((d) => d.x));\n  const yMin = Math.min(...raw.map((d) => d.y));\n  const yMax = Math.max(...raw.map((d) => d.y));\n  const data = distinctBy(\n    raw.map((orig) => ({\n      x:\n        rangePercentage({\n          value: orig.x,\n          min: xMin,\n          max: xMax,\n        }) * 100,\n      y:\n        rangePercentage({\n          value: orig.y,\n          min: yMin,\n          max: yMax,\n        }) * 100,\n      orig,\n    })),\n    (s) => s.x,\n  );\n\n  return (\n    <Base className={p.className} title={p.title}>\n      <Points>\n        {data.map((pt) => (\n          <Point\n            title={p.pointTitleF?.(pt.orig) ?? ''}\n            key={pt.x + ' ' + pt.y}\n            style={{\n              backgroundColor: pointColour,\n              borderColor: pointColour,\n              left: `calc(${pt.x}% - ${barWidth}px)`,\n              bottom: 0,\n              height: `calc(${pt.y}% + ${barWidth}px)`,\n            }}\n          />\n        ))}\n      </Points>\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport type { CSSProperties } from 'react';\nimport type { JSX } from 'react';\nimport React, { useState } from 'react';\n\nimport { Icon } from '../Icon';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: row;\n  &[data-mode='vert'] {\n    flex-flow: column;\n  }\n  overflow: hidden;\n  justify-content: space-around;\n  width: 100%;\n  margin: auto;\n`;\n\nconst Item = styled.div`\n  display: flex;\n  flex-flow: column;\n  align-items: center;\n  border-radius: 2rem;\n  justify-content: center;\n  height: calc(100% - 1rem);\n  padding-left: 1rem;\n  padding-right: 1rem;\n  width: 10rem;\n  &[data-selected='false'] {\n    opacity: 0.8;\n    cursor: pointer;\n  }\n`;\nconst IconStyled = styled(Icon)`\n  height: 1.5rem;\n  max-height: 80%;\n  max-width: fit-content;\n`;\nconst Text = styled.div`\n  max-height: 50%;\n  overflow: hidden;\n`;\n\nexport interface ITabBar {\n  onChangeIndex: (i: number) => void;\n\n  className?: string;\n  cookieDocument: string;\n  style?: CSSProperties;\n  items: {\n    text: string;\n    icon: (p: { style: { fill?: string } }) => JSX.Element;\n  }[];\n  theme?: {\n    /** default black */\n    front?: string;\n    /** default blue */\n    frontSelected?: string;\n    /** default #eee */\n    back?: string;\n  };\n  /** default 0 */\n  defaultSelectedIndex?: number;\n}\nexport const TabBar = (p: ITabBar) => {\n  const {\n    defaultSelectedIndex = 0,\n    theme: { back = '#eee', frontSelected = '#4d76ff', front = 'black' },\n  } = { ...p, theme: p.theme ?? {} };\n\n  const [index, setIndex] = useState<number>(defaultSelectedIndex);\n\n  return (\n    <Base className={p.className} style={p.style}>\n      {p.items.map((v, i) => {\n        const selected = index === i;\n        return (\n          <Item\n            style={{\n              backgroundColor: back,\n              color: front,\n              ...(selected && { color: frontSelected }),\n              maxWidth: `${100 / p.items.length}%`,\n            }}\n            data-selected={selected}\n            // eslint-disable-next-line react/no-array-index-key\n            key={i.toString()}\n            onClick={() => {\n              if (index === i) {\n                return;\n              }\n              setIndex(i);\n              p.onChangeIndex(i);\n            }}\n          >\n            <IconStyled style={{ width: '50%' }}>\n              {v.icon({\n                style: { ...(selected && { fill: frontSelected }) },\n              })}\n            </IconStyled>\n            <Text data-type=\"text\">{v.text}</Text>\n          </Item>\n        );\n      })}\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport type { JSX } from 'react';\nimport React from 'react';\n\nimport { groupByList } from '../../../common/helpers/groupBy';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: column;\n  width: 100%;\n  max-height: 100%;\n  overflow-y: auto;\n`;\n\nconst TableRow = styled.div`\n  display: flex;\n  border: solid 1px #ccc;\n  &[data-header='true'] {\n    border-bottom: solid 1px #888;\n  }\n  &:not(:first-of-type) {\n    border-top: 0;\n  }\n`;\n\nconst Group = styled.div`\n  display: flex;\n  flex-flow: column;\n  width: 100%;\n`;\n\nconst GroupTitle = styled.div`\n  font-size: 1.5rem;\n`;\n\nconst GroupWrap = styled.div`\n  display: flex;\n  flex-flow: column;\n  width: 100%;\n`;\n\nexport interface ITableItem {\n  content: JSX.Element;\n  groupTitle?: string;\n}\n\nexport interface ITable {\n  children: ITableItem[];\n  className?: string;\n  headerRow?: JSX.Element;\n}\nexport const Table = ({ children, className, headerRow }: ITable) => {\n  const grouped = groupByList(children, (s) => s.groupTitle);\n\n  return (\n    <Base className={className}>\n      {grouped.map((group) => (\n        <GroupWrap key={'gk' + group.key}>\n          {group.key && (\n            <GroupTitle key={`gt${group.key}`}>{group.key}</GroupTitle>\n          )}\n          <Group key={`g${group.key}`}>\n            {headerRow && (\n              <TableRow data-header=\"true\" key={`headrow${group.key}`}>\n                {headerRow}\n              </TableRow>\n            )}\n            {group.items.map((item) => (\n              <TableRow key={item.content.key}>{item.content}</TableRow>\n            ))}\n          </Group>\n        </GroupWrap>\n      ))}\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { useState } from 'react';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: row;\n  max-height: 100%;\n`;\n\nconst Input = styled.input`\n  flex-grow: 1;\n  border: solid 3px #ccc;\n  border-right: 0;\n  padding-left: 0.5rem;\n  border-radius: 0.5rem 0 0 0.5rem;\n  overflow: hidden;\n  font-size: 1.2rem;\n  &[data-valid='false'] {\n    border-color: indianred;\n  }\n  outline: 0;\n`;\n\nconst Button = styled.button`\n  padding: 2rem;\n  padding-top: 1rem;\n  padding-bottom: 1rem;\n  border: 0;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: rgb(136 119 227);\n  color: white;\n  font-weight: bold;\n  border-radius: 0 0.5rem 0.5rem 0;\n  overflow: hidden;\n  user-select: none;\n  cursor: pointer;\n  &[data-valid='false'] {\n    cursor: not-allowed;\n    border-color: indianred;\n    background-color: #ccc;\n  }\n`;\nexport interface ITextWithButton {\n  /** default \"Submit\" */\n  submitText?: string;\n  placeholder?: string;\n  /** if provided will validate and block submission accordingly */\n  validateF?: (s: string) => boolean;\n  onSubmit: (s: string) => void;\n}\n\nexport const TextWithButton = ({\n  submitText = 'Submit',\n  placeholder,\n  validateF,\n  onSubmit,\n}: ITextWithButton) => {\n  const [value, setValue] = useState('');\n  const valid = !validateF ? true : validateF(value);\n\n  return (\n    <Base>\n      <Input\n        data-type=\"input\"\n        data-valid={valid}\n        placeholder={placeholder}\n        value={value}\n        onChange={(s) => setValue(s.target.value)}\n        onKeyDown={(e) => e.key === 'Enter' && valid && onSubmit(value)}\n      />\n      <Button\n        data-type=\"button\"\n        data-valid={valid}\n        disabled={!valid}\n        onClick={() => valid && onSubmit(value)}\n      >\n        {submitText}\n      </Button>\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport type { FC } from 'react';\nimport React from 'react';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: column;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  svg {\n    overflow: initial;\n  }\n`;\nexport interface ITimelineChartSeries {\n  data: {\n    x: number;\n    y: number;\n  }[];\n  /** shown on page */\n  label?: string;\n  key: string;\n  color: string;\n  /** optional onclick href */\n  onClick?: () => void;\n  /** hover text */\n  title?: string;\n}\n\nexport interface ITimelineChart {\n  series: ITimelineChartSeries[];\n  strokeWidth?: number;\n  className?: string;\n}\n\nexport const TimelineChart: FC<ITimelineChart> = ({\n  series,\n  strokeWidth = 3,\n  className,\n}) => {\n  if (series.length === 0) {\n    return <Base />;\n  }\n\n  const width = 600;\n  const height = 200;\n  const xValues = series.flatMap((s) => s.data.map((d) => d.x));\n  const yValues = series.flatMap((s) => s.data.map((d) => d.y));\n  const xMin = Math.min(...xValues);\n  const xMax = Math.max(...xValues);\n  const yMin = Math.min(...yValues);\n  const yMax = Math.max(...yValues);\n  const xScale = (x: number): number =>\n    Math.ceil(width * ((x - xMin) / (xMax - xMin)));\n\n  const yScale = (y: number): number => {\n    let ret = Math.ceil(height * ((yMax - y) / (yMax - yMin)));\n    if (isNaN(ret)) {\n      ret = y;\n    }\n    return ret;\n  };\n\n  const getPathData = ({ data }: ITimelineChartSeries): string => {\n    const pd1 = data\n      .sort((a, b) => (a.x < b.x ? -1 : 1))\n      .map(({ x, y }) => {\n        const xScaled = xScale(x);\n        const yScaled = yScale(y);\n\n        return { xScaled, yScaled };\n      });\n\n    const pathData = pd1.map(({ xScaled, yScaled }, i) =>\n      i === 0 ? `M${xScaled} ${yScaled}` : ` L${xScaled} ${yScaled}`,\n    );\n\n    return pathData.join('\\n');\n  };\n\n  return (\n    <Base className={className}>\n      <svg viewBox={`0 -10 ${width} ${height + 20}`}>\n        {series.map(({ color, data, label, key, onClick, title }) => (\n          <g key={key}>\n            <title>{title || label}</title>\n            <path\n              d={getPathData({ color, data, label, key })}\n              fill=\"none\"\n              stroke={color}\n              strokeWidth={strokeWidth}\n              onClick={() => onClick?.()}\n              style={{ cursor: onClick ? 'pointer' : 'default' }}\n            />\n            {label && (\n              <>\n                <text\n                  x={xScale(data[0]?.x) + strokeWidth * 2}\n                  y={yScale(data[data.length - 1]?.y)}\n                  fontSize=\"12\"\n                  textAnchor=\"middle\"\n                  dominantBaseline=\"middle\"\n                  stroke=\"white\"\n                  strokeWidth={'3px'}\n                >\n                  {label}\n                </text>\n\n                <text\n                  x={xScale(data[0]?.x) + strokeWidth * 2}\n                  y={yScale(data[data.length - 1]?.y)}\n                  fontSize=\"12\"\n                  textAnchor=\"middle\"\n                  dominantBaseline=\"middle\"\n                  fill=\"black\"\n                >\n                  {label}\n                </text>\n              </>\n            )}\n          </g>\n        ))}\n      </svg>\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { createContext, useEffect, useMemo, useState } from 'react';\n\nimport { random } from '../../../common/helpers/random';\nimport { Warning } from '../../icons/Warning';\nimport type { IVarStyles } from '../../styles/common';\nimport { getVarStyles } from '../../styles/common';\nimport { FlexColumn } from '../FlexColumn';\nimport { FlexRow } from '../FlexRow';\nimport { ProgressBar } from '../ProgressBar';\nimport { Cross } from './Cross';\nimport { Tick } from './Tick';\nimport type {\n  IToastInt,\n  IToastProviderOptions,\n  TAddToast,\n  TAddToastDetailed,\n} from './types';\n\nexport const ToastContext = createContext<{\n  addToast: TAddToast;\n  addToastDetailed: TAddToastDetailed;\n}>({} as any);\nconst ToastContainerStyle = styled.div`\n  position: fixed;\n  bottom: 0;\n  right: 0;\n  margin: 0.5rem;\n  z-index: 10000;\n\n  display: flex;\n  flex-flow: column;\n  align-items: flex-end;\n  max-width: 50vw;\n`;\n\nconst ToastStyle = styled.div`\n  display: flex;\n  flex-flow: row wrap;\n  align-items: center;\n  padding: 0.5rem;\n  position: relative;\n  font-size: 1.2rem;\n  &:not(:last-of-type) {\n    margin-bottom: 8px;\n  }\n\n  border: solid 1px;\n  border-radius: 6px;\n`;\n\nconst CloseStyle = styled.span`\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 0.5rem;\n  height: 0.5rem;\n\n  cursor: pointer;\n  border-radius: 50%;\n  padding: 0.5rem;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  color: white;\n  z-index: 1;\n  &:hover {\n    background-color: var(--bg);\n  }\n`;\nconst Icon = styled.div`\n  width: 1.5rem;\n  height: 1.5rem;\n  margin-right: 0.5rem;\n`;\n\nconst ProgressBarStyled = styled(ProgressBar)`\n  height: 0.75rem;\n  margin-top: 0.5rem;\n`;\n\nexport const Toast = ({\n  toast,\n  close,\n  style,\n}: {\n  toast: IToastInt;\n  style: IVarStyles;\n  close: (s: string) => void;\n}) => {\n  let closeMs: number | undefined;\n  if (toast.options?.autoClose) {\n    closeMs = toast.options.autoClose;\n  } else if (toast.options?.autoClose === undefined) {\n    if (toast.options?.appearance === 'success') {\n      closeMs = 5000;\n    } else {\n      closeMs = 10000;\n    }\n  }\n\n  let icon = <Tick />;\n\n  switch (toast.options?.appearance) {\n    case 'error': {\n      icon = <Cross />;\n      break;\n    }\n    case 'warning': {\n      icon = <Warning />;\n      break;\n    }\n\n    case 'success':\n    default: {\n      icon = <Tick />;\n      break;\n    }\n    case undefined:\n  }\n\n  useEffect(() => {\n    if (!closeMs) {\n      return;\n    }\n    const timeout = setTimeout(() => close(toast.id), closeMs);\n    return () => clearTimeout(timeout);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const closeStyle = { color: style.color, '--bg': style.borderColor };\n  const toastStyle = {\n    ...style,\n    boxShadow: `hsl(from ${style.borderColor} h s 25%) 0px 7px 29px 0px`,\n  };\n\n  if (toast.type === 'standard') {\n    return (\n      <ToastStyle style={toastStyle}>\n        <CloseStyle onClick={() => close(toast.id)} style={closeStyle}>\n          &times;\n        </CloseStyle>\n        <Icon style={{ fill: style.color }}>{icon}</Icon>\n        {toast.message}\n        {closeMs !== undefined && (\n          <ProgressBarStyled\n            max={100}\n            min={0}\n            dotPercentages={null}\n            transitionToMs={closeMs}\n          />\n        )}\n      </ToastStyle>\n    );\n  }\n  return (\n    <ToastStyle style={toastStyle}>\n      <CloseStyle onClick={() => close(toast.id)} style={closeStyle}>\n        &times;\n      </CloseStyle>\n      <FlexRow noWrap center>\n        {toast.icon === undefined && <Icon>{icon}</Icon>}\n        {toast.icon}\n        <FlexColumn\n          style={{ marginLeft: toast.icon === null ? '0' : '0.5rem' }}\n        >\n          <b>{toast.title}</b>\n          {toast.content}\n        </FlexColumn>\n      </FlexRow>\n\n      {closeMs !== undefined && (\n        <ProgressBarStyled\n          max={100}\n          min={0}\n          dotPercentages={null}\n          transitionToMs={closeMs}\n        />\n      )}\n    </ToastStyle>\n  );\n};\n\nexport const ToastProvider = ({\n  children,\n  providerOptions,\n}: {\n  children: React.ReactNode;\n  providerOptions?: IToastProviderOptions;\n}) => {\n  const [toasts, setToasts] = useState<IToastInt[]>([]);\n  const addToast: TAddToast = (message, options) =>\n    setToasts((currentToasts) => [\n      ...currentToasts.filter(\n        (ct) =>\n          ct.type === 'detailed' ||\n          ct.message !== message ||\n          JSON.stringify(ct.options) !== JSON.stringify(options),\n      ),\n      { id: random(10000).toString(), message, options, type: 'standard' },\n    ]);\n\n  const addToastDetailed: TAddToastDetailed = (p, options) =>\n    setToasts((currentToasts) => [\n      ...currentToasts,\n      { id: random(10000).toString(), ...p, options, type: 'detailed' },\n    ]);\n\n  const close = (id: string) =>\n    setToasts((currentToasts) =>\n      currentToasts.filter((toast) => toast.id !== id),\n    );\n  const contextValue = useMemo(() => ({ addToast, addToastDetailed }), []);\n  const style = getVarStyles(providerOptions?.style);\n\n  return (\n    <ToastContext.Provider value={contextValue}>\n      {children}\n      <ToastContainerStyle>\n        {toasts.map((toast) => (\n          <Toast key={toast.id} toast={toast} close={close} style={style} />\n        ))}\n      </ToastContainerStyle>\n    </ToastContext.Provider>\n  );\n};\n","import styled from '@emotion/styled';\nimport React from 'react';\n\nimport type { TreeNodeData, TreeNodeOut } from './types';\n\nconst Base = styled.div`\n  padding: 0.5rem;\n  border: solid 1px black;\n  background-color: white;\n  color: black;\n`;\n\nconst Title = styled.div`\n  font-weight: bold;\n`;\n\nexport const TooltipContent = ({\n  data,\n  node,\n  head,\n}: {\n  data: TreeNodeData;\n  node: TreeNodeOut;\n  head: TreeNodeOut;\n}) => {\n  let rows: string[] = [];\n\n  let n: TreeNodeOut | undefined = node;\n  while (n) {\n    const t =\n      data.titleFn?.({\n        path: n.name,\n        pathCount: n.size,\n        fullCount: head.size,\n      }) || `${n.name} (${n.size}/${head.size})`;\n    rows = [t, ...rows];\n    n = n.parent;\n  }\n\n  return (\n    <Base>\n      <Title>\n        {rows.map((r, i) => (\n          <div key={r} style={{ marginLeft: `${i * 2}px` }}>\n            {r}\n          </div>\n        ))}\n      </Title>\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { useEffect, useRef, useState } from 'react';\n\nimport { useResize } from '../../helpers/useResize';\nimport type { IUseTooltip } from '../../helpers/useTooltip';\nimport { useTooltip } from '../../helpers/useTooltip';\nimport { getColourWheel } from '../../styles';\nimport { HardOutline, TextOverflowEllipsis } from '../../styles/common';\nimport { convertToRaw } from './helpers';\nimport { TooltipContent } from './TooltipContent';\nimport type { TreeNodeData, TreeNodeOut } from './types';\n\nconst Base = styled.div`\n  border: solid 1px #ccc;\n  max-height: 100%;\n  overflow-y: auto;\n`;\n\nconst NodeChildren = styled.div`\n  display: flex;\n  flex-flow: row wrap;\n  justify-content: center;\n`;\nconst Node = styled.div`\n  margin: 1px;\n  padding: 2px;\n  display: flex;\n  flex-flow: column;\n  height: min-content;\n  overflow: hidden;\n  &[data-leaf='true'] {\n    width: 100%;\n    height: 100%;\n    min-height: 1rem;\n    min-width: 1rem;\n    max-width: 10rem;\n    max-height: 10rem;\n  }\n`;\n\nconst Title = styled.div`\n  color: white;\n  word-break: break-all;\n  ${HardOutline('black')};\n  ${TextOverflowEllipsis(1)};\n  min-height: 1rem;\n  line-height: 1rem;\n`;\n\nconst Render = ({\n  n,\n  depth,\n  head,\n  headDim,\n  tnd,\n  UT,\n}: {\n  tnd: TreeNodeData;\n  n: TreeNodeOut;\n  depth: number;\n  head: TreeNodeOut;\n  headDim: { width: number; height: number };\n  UT: IUseTooltip<ITreeChartUTData>;\n}) => {\n  const children = Object.values(n.children);\n  const leaf = children.length === 0;\n  const sizeMult = n.size / head.size;\n\n  const biggerDim = Math.max(headDim.width, headDim.height);\n  const nodeSize = Math.floor(biggerDim * sizeMult).toString();\n\n  return (\n    <Node\n      data-treenode\n      data-leaf={leaf.toString()}\n      style={{\n        backgroundColor: getColourWheel(depth),\n        ...(leaf &&\n          nodeSize && {\n            width: nodeSize + 'px',\n            height: nodeSize + 'px',\n          }),\n      }}\n      key={n.name}\n      data-ch={n.children.length}\n      data-size={n.size}\n      onMouseLeave={() => UT.setPos(undefined)}\n      onMouseMove={(element) => {\n        UT.setPos({\n          element,\n          parent: null,\n          data: { data: tnd, node: n, head },\n        });\n        element.preventDefault();\n        element.stopPropagation();\n      }}\n    >\n      {n.name && <Title>{n.name}</Title>}\n      {children.length > 0 && (\n        <NodeChildren data-type=\"nc\">\n          {children.map((c) =>\n            Render({\n              UT,\n              n: c,\n              depth: depth + 1,\n              head,\n              headDim,\n              tnd,\n            }),\n          )}\n        </NodeChildren>\n      )}\n    </Node>\n  );\n};\n\ninterface ITreeChartUTData {\n  data: TreeNodeData;\n  node: TreeNodeOut;\n  head: TreeNodeOut;\n}\n\nexport const TreeChart = (tnd: TreeNodeData) => {\n  const UT = useTooltip<ITreeChartUTData>();\n  const head = convertToRaw({ tnd });\n\n  const pd = useResize();\n\n  const [headDim, setHeadDim] = useState<\n    { width: number; height: number } | undefined\n  >();\n\n  const r = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (!r.current) {\n      return;\n    }\n    const width = r.current.clientWidth;\n    const height = r.current.clientHeight || r.current.clientWidth;\n    setHeadDim({\n      width,\n      height,\n    });\n  }, [pd]);\n\n  if (head.size === 0) {\n    return <div />;\n  }\n\n  return (\n    <Base ref={r} className={tnd.className} style={tnd.style}>\n      <UT.Comp pos={UT.pos}>\n        {({ data }) => <TooltipContent {...data} />}\n      </UT.Comp>\n      {headDim &&\n        Render({\n          UT,\n          tnd,\n          n: head,\n          depth: 0,\n          head,\n          headDim,\n        })}\n    </Base>\n  );\n};\n","'use client';\nimport styled from '@emotion/styled';\nimport React, { useEffect, useState } from 'react';\n\nimport { notEmpty } from '../../../common/helpers/array';\nimport { UserOutline } from '../../icons/UserOutline';\n\nconst Base = styled.div`\n  border-radius: 50%;\n  border: solid 1px white;\n  overflow: hidden;\n  position: relative;\n\n  @keyframes color {\n    0% {\n      fill: #bbb;\n    }\n    50% {\n      fill: #aaa;\n    }\n    100% {\n      fill: #bbb;\n    }\n  }\n  svg {\n    transition: all 1s;\n  }\n  &[data-fail='0'] {\n    svg {\n      fill: white;\n    }\n  }\n  &[data-fail='0.5'] {\n    svg {\n      animation-name: color;\n      animation-duration: 2s;\n      animation-iteration-count: infinite;\n    }\n  }\n  &[data-fail='1'] {\n    svg {\n      fill: #333;\n    }\n  }\n`;\n\nconst Img = styled.img`\n  position: absolute;\n  top: 0;\n  left: 0;\n`;\n\nexport interface IUserImage {\n  image?: string;\n  className?: string;\n  /** default \"user image\" */\n  title?: string;\n  opt?: { width?: string; height?: string };\n}\n\nexport const UserImage = ({\n  image,\n  className,\n  title = 'user image',\n  opt,\n}: IUserImage) => {\n  const [failed, setFailed] = useState<0 | 0.5 | 1>(0);\n  useEffect(() => {\n    setFailed(0.5);\n  }, []);\n\n  return (\n    <Base\n      className={className}\n      title={title}\n      data-fail={failed}\n      style={{\n        width: opt?.width || '100%',\n        height: opt?.height || '100%',\n        maxWidth: '100%',\n        maxHeight: '100%',\n      }}\n    >\n      {UserOutline}\n      {failed !== 1 && (\n        <Img\n          alt=\"user\"\n          src={image}\n          onError={() => setFailed(1)}\n          onAbort={() => setFailed(1)}\n          style={{ width: '100%', height: '100%', objectFit: 'cover' }}\n        />\n      )}\n    </Base>\n  );\n};\n\nexport interface IUserProfileImage {\n  className?: string;\n  user?: { picture: string; fullname: string; userId: string };\n  /** 100% if not provided. default 2.5rem */\n  opt?: { width?: string; height?: string };\n}\nexport const UserProfileImage = ({\n  className,\n  user,\n  opt = { width: '2.5rem', height: '2.5rem' },\n}: IUserProfileImage) => {\n  const image = user?.picture;\n\n  const titleA = [user?.fullname, user?.userId].filter(notEmpty);\n  const title = titleA.length === 0 ? '' : titleA.join(' - ');\n\n  return (\n    <UserImage image={image} title={title} className={className} opt={opt} />\n  );\n};\n"],"names":[],"sourceRoot":""}