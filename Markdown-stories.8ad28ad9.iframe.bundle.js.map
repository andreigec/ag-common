{"version":3,"file":"Markdown-stories.8ad28ad9.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;AA6MA","sources":["webpack://ag-common/./src/ui/components/Markdown/index.tsx"],"sourcesContent":["import styled from '@emotion/styled';\nimport type { JSX } from 'react';\nimport React from 'react';\n\nimport { hashCode } from '../../../common';\nimport { insertElementAtIndex } from '../../../common/helpers/array';\nimport { trimSide } from '../../../common/helpers/string/trim';\n\nconst injectTable = ({\n  tableRows,\n  preprocessText,\n}: {\n  tableRows: string[];\n  preprocessText: (s: string) => string | JSX.Element;\n}) => (\n  <table key={hashCode(JSON.stringify(tableRows))}>\n    <thead>\n      <tr>\n        {tableRows[0]\n          .split('|')\n          .map((header) => header.trim())\n          .map((header) => (\n            <th key={header}>{preprocessText(header)}</th>\n          ))}\n      </tr>\n    </thead>\n    <tbody>\n      {tableRows.slice(2).map((row) => {\n        const cells = row.split('|').map((cell) => cell.trim());\n        return (\n          <tr key={row}>\n            {cells.map((cell) => (\n              <td key={cell}>{preprocessText(cell)}</td>\n            ))}\n          </tr>\n        );\n      })}\n    </tbody>\n  </table>\n);\n\nconst injectGroup = ({\n  output,\n  pos,\n  wrap,\n}: {\n  pos: {\n    outputIndex: number;\n    matchLine: string;\n  };\n  output: JSX.Element[];\n  wrap: (items: JSX.Element[]) => JSX.Element;\n}) => {\n  const outputEndIndex = output.length;\n  const sum: JSX.Element[] = [];\n\n  for (let a = pos.outputIndex; a <= outputEndIndex; a += 1) {\n    sum.push(output[a]);\n    delete output[a];\n  }\n  output = insertElementAtIndex(output, wrap(sum), pos.outputIndex);\n  return output;\n};\n\nfunction renderMarkdown({\n  markdown,\n  preprocessText = (s) => s,\n}: {\n  preprocessText?: (s: string) => string | JSX.Element;\n  markdown: string;\n}) {\n  const lines = markdown.split('\\n');\n  let output: JSX.Element[] = [];\n\n  let ol: { outputIndex: number; matchLine: string } | undefined;\n  let ul: { outputIndex: number; matchLine: string } | undefined;\n  let tableRows: string[] = [];\n  let a = -1;\n  do {\n    a += 1;\n    const line = lines[a] ?? '';\n    const la = line + a;\n\n    const star = /\\*\\*(.*?)\\*\\*/gim;\n    //handle inline **s\n    if (line.match(star)) {\n      output.push(\n        <p\n          key={la}\n          dangerouslySetInnerHTML={{\n            __html: line.replace(star, `<b>$1</b>`).trim(),\n          }}\n        />,\n      );\n      continue;\n    }\n\n    //table\n    if (line.startsWith('|')) {\n      tableRows.push(line);\n      continue;\n    } else {\n      if (tableRows.length > 0) {\n        output.push(injectTable({ tableRows, preprocessText }));\n        tableRows = [];\n      }\n    }\n    //ol\n    if (line.match(/^[0-9]+\\./gim)) {\n      if (ol === undefined) {\n        ol = { matchLine: line, outputIndex: output.length };\n      }\n    } else if (ol && ol.matchLine !== line) {\n      output = injectGroup({\n        output,\n        pos: ol,\n        wrap: (i) => <ol key={i[0].key}>{i}</ol>,\n      });\n      ol = undefined;\n    }\n\n    //ul\n    if (line.startsWith('-') || line.startsWith('*')) {\n      if (ul === undefined) {\n        ul = { matchLine: line, outputIndex: output.length };\n      }\n    } else if (ul && ul.matchLine !== line) {\n      output = injectGroup({\n        output,\n        pos: ul,\n        wrap: (i) => <ul key={i[0].key}>{i}</ul>,\n      });\n      ul = undefined;\n    }\n\n    // h1\n    if (line.startsWith('#')) {\n      const level = line.match(/^#+/)?.[0]?.length ?? 0;\n      const t = trimSide(line, true, '#').trim();\n      if (level === 1) {\n        output.push(<h1 key={t}>{preprocessText(t)}</h1>);\n      } else if (level === 2) {\n        output.push(<h2 key={t}>{preprocessText(t)}</h2>);\n      } else if (level === 3) {\n        output.push(<h3 key={t}>{preprocessText(t)}</h3>);\n      } else if (level === 4) {\n        output.push(<h4 key={t}>{preprocessText(t)}</h4>);\n      } else if (level === 5) {\n        output.push(<h5 key={t}>{preprocessText(t)}</h5>);\n      } else if (level >= 6) {\n        output.push(<h6 key={t}>{preprocessText(t)}</h6>);\n      }\n    }\n    //ul - li\n    else if (line.startsWith('*') || line.startsWith('-')) {\n      const t = line.slice(2).trim();\n      if (t.length > 0) {\n        output.push(<li key={t}>{preprocessText(t)}</li>);\n      }\n    }\n    //ol - li\n    else if (line.match(/^[0-9]+\\./gim)) {\n      const t = line.slice(3).trim();\n      if (t.length > 0) {\n        output.push(<li key={t}>{preprocessText(t)}</li>);\n      }\n    }\n    //text\n    else {\n      if (line.length > 0) {\n        output.push(<p key={la}>{preprocessText(line)}</p>);\n      }\n    }\n  } while (a < lines.length);\n  return output;\n}\n\nconst Base = styled.div`\n  > * {\n    margin: 0;\n    white-space: pre-wrap;\n  }\n  ul {\n    display: grid;\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  ol,\n  ul,\n  table {\n    margin-bottom: 1rem;\n  }\n`;\n\nexport interface IMarkdown {\n  markdown: string;\n  className?: string;\n  /** run after html is generated for markdown, but before applied */\n  preprocessText?: (s: string) => string | JSX.Element;\n}\nexport const Markdown = (p: IMarkdown) => (\n  <Base className={p.className}>\n    {renderMarkdown({\n      preprocessText: p.preprocessText,\n      markdown: p.markdown.trim(),\n    })}\n  </Base>\n);\n"],"names":[],"sourceRoot":""}