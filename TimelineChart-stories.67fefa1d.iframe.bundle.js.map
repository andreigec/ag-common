{"version":3,"file":"TimelineChart-stories.67fefa1d.iframe.bundle.js","mappings":";;;;;;;;;;AAqCA","sources":["webpack://ag-common/./src/ui/components/TimelineChart/index.tsx"],"sourcesContent":["'use client';\nimport styled from '@emotion/styled';\nimport type { FC } from 'react';\nimport React from 'react';\n\nconst Base = styled.div`\n  display: flex;\n  flex-flow: column;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  svg {\n    overflow: initial;\n  }\n`;\nexport interface ITimelineChartSeries {\n  data: {\n    x: number;\n    y: number;\n  }[];\n  /** shown on page */\n  label?: string;\n  key: string;\n  color: string;\n  /** optional onclick href */\n  onClick?: () => void;\n  /** hover text */\n  title?: string;\n}\n\nexport interface ITimelineChart {\n  series: ITimelineChartSeries[];\n  strokeWidth?: number;\n  className?: string;\n}\n\nexport const TimelineChart: FC<ITimelineChart> = ({\n  series,\n  strokeWidth = 3,\n  className,\n}) => {\n  if (series.length === 0) {\n    return <Base />;\n  }\n\n  const width = 600;\n  const height = 200;\n  const xValues = series.flatMap((s) => s.data.map((d) => d.x));\n  const yValues = series.flatMap((s) => s.data.map((d) => d.y));\n  const xMin = Math.min(...xValues);\n  const xMax = Math.max(...xValues);\n  const yMin = Math.min(...yValues);\n  const yMax = Math.max(...yValues);\n  const xScale = (x: number): number =>\n    Math.ceil(width * ((x - xMin) / (xMax - xMin)));\n\n  const yScale = (y: number): number => {\n    let ret = Math.ceil(height * ((yMax - y) / (yMax - yMin)));\n    if (isNaN(ret)) {\n      ret = y;\n    }\n    return ret;\n  };\n\n  const getPathData = ({ data }: ITimelineChartSeries): string => {\n    const pd1 = data\n      .sort((a, b) => (a.x < b.x ? -1 : 1))\n      .map(({ x, y }) => {\n        const xScaled = xScale(x);\n        const yScaled = yScale(y);\n\n        return { xScaled, yScaled };\n      });\n\n    const pathData = pd1.map(({ xScaled, yScaled }, i) =>\n      i === 0 ? `M${xScaled} ${yScaled}` : ` L${xScaled} ${yScaled}`,\n    );\n\n    return pathData.join('\\n');\n  };\n\n  return (\n    <Base className={className}>\n      <svg viewBox={`0 -10 ${width} ${height + 20}`}>\n        {series.map(({ color, data, label, key, onClick, title }) => (\n          <g key={key}>\n            <title>{title || label}</title>\n            <path\n              d={getPathData({ color, data, label, key })}\n              fill=\"none\"\n              stroke={color}\n              strokeWidth={strokeWidth}\n              onClick={() => onClick?.()}\n              style={{ cursor: onClick ? 'pointer' : 'default' }}\n            />\n            {label && (\n              <>\n                <text\n                  x={xScale(data[0]?.x) + strokeWidth * 2}\n                  y={yScale(data[data.length - 1]?.y)}\n                  fontSize=\"12\"\n                  textAnchor=\"middle\"\n                  dominantBaseline=\"middle\"\n                  stroke=\"white\"\n                  strokeWidth={'3px'}\n                >\n                  {label}\n                </text>\n\n                <text\n                  x={xScale(data[0]?.x) + strokeWidth * 2}\n                  y={yScale(data[data.length - 1]?.y)}\n                  fontSize=\"12\"\n                  textAnchor=\"middle\"\n                  dominantBaseline=\"middle\"\n                  fill=\"black\"\n                >\n                  {label}\n                </text>\n              </>\n            )}\n          </g>\n        ))}\n      </svg>\n    </Base>\n  );\n};\n"],"names":[],"sourceRoot":""}